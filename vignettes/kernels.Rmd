---
title: "Kernel functions in deconvolution"
author: "Guillermo Basulto-Elias"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Kernel whose Fourier transform are preferred in kernel deconvolution methods due to their theoretical and numerical advantages. In fact, only those Fourier transforms are used, rather than the kernel functions themselves. Thus, we have a function that can calculates kernel and product kernels.

## Kernel functions and their Fourier transforms

```{r, fig.width= 7, fig.height= 5}
## Load package
library(kerdec)

## Define evaluation grid and kernels.
t <- seq(-1.3, 1.7, by = 0.01)
ker <- c("sinc", "triangular", "triweight", "tricube", "flat-top")

## Evaluate Ft of kernels.
values <- sapply(1:5, function(idx) ft_kernel(t, ker[idx]))

## Generate plots.
plot(t, rep(0, length(t)), type = "n", ylim = c(-0.01, 1),
     ylab = "value", main = "Fourier transform of kernels")
for(idx in 1:5){
  lines(t, values[, idx], col = idx + 1, lty = idx, lwd = 2)
}
legend("topright", ker, col = 2:6, lty = 1:5, lwd = 2)

```

```{r, fig.width= 7, fig.height= 5}
library(kerdec)

ker <- c("sinc", "triangular", "triweight", "tricube", "flat-top")
names(ker) <- ker

vals <- lapply(ker,
               function(krnl) 
                 fourierin::fourierin(function(t) ft_kernel(t, krnl), 
                                      a = -1, b = 1, c = -9, d = 9, 
                                      r = -1, s = -1, resol = 256))
x <- vals$sinc$w
vals <- lapply(vals, function(out) c(Re(out$values)))

plot(x, vals[["sinc"]], type = "n", 
     ylab = "value", main = "Kernel functions")
abline(h = 0, col = "lightgray")
for(idx in 1:5){
  lines(x, vals[[idx]], col = idx + 1, lty = idx, lwd = 2)
}
legend("topright", ker, col = 2:6, lty = 1:5, lwd = 2)

```


## Examples 

## Product kernels
