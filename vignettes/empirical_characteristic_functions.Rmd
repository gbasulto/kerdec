---
title: "Empirical Characteristic Functions"
author: "Guillermo Basulto-Elias"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The empirical characteristic function of the random sample $\boldsymbol{X}_1, \ldots, \boldsymbol{X}_n$, where $\boldsymbol{X}_i$'s  are random vectors of size $d$ is defined as 
$$
\frac{1}{n}\sum_{j=1}^{n}\exp 
\left( \imath \langle \boldsymbol{X}_j, \boldsymbol{t}\rangle\right),
$$
where $\langle \cdot, \cdot \rangle$ is the usual inner product in $\mathbb{R}^d$. We present here functions do to find empirical characteristic function or its module and imaginary and real parts. 

Empirical characteristic functions are crucial for kernel deconvolution formulas and they are also used when the error distribution is not considered known. On the other hand, evaluate them can be time-consuming, thus, we have speeded up the evaluation time by implementing it in `C++` and allowing to compute only the part that we might be interested in, that is, the real or imaginary part, the modulus or the empirical characteristic function itself.

All the functions here described calculate empirical characteristic functions of samples from univariate or multivariate random variables.

## Computing empirical characteristic functions faster

Having a function that computes the empirical characteristic function (ecf) is practical, but if what the user needs is only the real part of the empirical characteristic function it is more efficient to do exactly that. The same is tru for the modulus and the imaginary part. Taking the real part of the ecf takes twice the time it takes to compute directly the real part.

Therefore, functions have been implemented in `C++` for doing such operations directly, but only the wrappers in `R` are available to users.

Here it is an example of three ways to find the imaginary part of the ecf.

- ecf_im_cpp (way1): is the fastest, but it requires arguments to be
matrices with the appropriate arguments.

- ecf_imag (way2): is almost as fast as the function above, but it allows
vectors when it applies (either when the random sample is
unidimensional or the characteristic function is evaluated at only
one point).

- ecf_cpp (way3): takes twice the time, but it also computes the real
part.

```{r}
library(kerdec)

## Generate sample and define two points to evaluate the functions
smp <- rpois(5, lambda = 100)
t <- c(-1, 1)

## Evaluate the functions and arrange them in a dataframe.
dat <- 
  data.frame(
    way1 = kerdec:::ecf_im_cpp(matrix(t), matrix(smp)),
    way2 = ecf_imag(t, smp),
    way3 = Im(ecf(t, smp))
  )

## kable function is used for displaying the table nicely.
knitr::kable(dat)
```

## Univariate empirical characteristic function

This is a brief demonstration of the use of univariate functions for empirical characteristic functions. Observe that they all can be evaluated in vectors.

```{r, fig.height= 6, fig.width= 7}
library(kerdec)

## Parameters of Poisson distribution, sample size and grid size
lambda <- 10
n <- 150                                # Sample size
m <- 200                                # Grid size
t <- seq(-5, 5, length.out = m)         # Evaluation grid
smp <- rpois(n, lambda)                 # Random sample

## Compute empirical characteristic values and characteristic function
## values
real <- ecf_real(t, smp)
imag <- ecf_imag(t, smp)
modu <- ecf_mod(t, smp)
true <- exp(lambda*(exp(1i*t) - 1))

## Make plots
                                        # Real
plot(t, real, type = "l", col = 3)
lines(t, Re(true), col = 4)
title("Real part of empirical and true characteristic functions")
legend("topleft", legend = c("ecf", "cf"), col = 3:4, lwd = 2)

                                        # Imaginary
plot(t, imag, type = "l", col = 3)
lines(t, Im(true), col = 4)
title("Imaginary part of empirical and true characteristic functions")
legend("topleft", legend = c("ecf", "cf"), col = 3:4, lwd = 2)

                                        # Modulus
plot(t, modu, type = "l", col = 3, ylim = c(-0.05, 1))
lines(t, Mod(true), col = 4)
title("Modulus of empirical and true characteristic functions")
legend("topleft", legend = c("ecf", "cf"), col = 3:4, lwd = 2)

```

##  Empirical characteristic function of random vectors

The functions on this package work for ecf of random vectors. Since visualization of ecf of random vectors is not straightforward, we present an example of a random vector of size three and show a plot of how the absolute error (of the ecf evaluated in $10^3$ points) decreases as the sample size increases. 

It is worth mentioning that the ecf functions receive a vector of size $m$ or a $m \times d$ matrix as evaluation grid and a $n \times d$ as sample, where $m$ is the number of points where the ecf will be evaluated, $d$ the size of the random vector and $n$ the sample size.

```{r, fig.width= 7, fig.height= 6}
library(kerdec)

## Parameters of bivariate normal distribution
mu <- c(-1, 0, 1)
sig <- diag(1:3)

## Characteristic function
## s is n x d
phi <- function(s) {
    complex(modulus = exp(- 0.5*rowSums(s*(s %*% sig))),
            argument = s %*% mu)
}

## Random sample of dimension 3.
rndm <- function(n) {
    cbind(rnorm(n, mu[1], sig[1, 1]),
          rnorm(n, mu[2], sig[2, 2]),
          rnorm(n, mu[3], sig[3, 3]))
}

## Create evaluation grid.
grid_1d <- seq(-3, 3, length.out = 10)
grid <- as.matrix(expand.grid(t1 = grid_1d,
                              t2 = grid_1d,
                              t3 = grid_1d))

## Compute absolute error of modules
n <- seq(500, 5000, by = 500)
abs_error <- sapply(n, function(nn)
    sum(abs(Mod(phi(grid)) - ecf_mod(t = grid, smp = rndm(nn)))))

## Generate plot
plot(n, abs_error, type = "b", col = "magenta")

```

